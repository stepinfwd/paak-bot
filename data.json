{
    "algorithms": {
        "bubble": "function bubbleSort(arr) { let n = arr.length; for (let i = 0; i < n - 1; i++) { for (let j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr; }",
        "selection": "function selectionSort(arr) { let n = arr.length; for (let i = 0; i < n - 1; i++) { let minIdx = i; for (let j = i + 1; j < n; j++) { if (arr[j] < arr[minIdx]) minIdx = j; } [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]]; } return arr; }",
        "insertion": "function insertionSort(arr) { let n = arr.length; for (let i = 1; i < n; i++) { let key = arr[i], j = i - 1; while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr; }",
        "merge": "function mergeSort(arr) { if (arr.length <= 1) return arr; let mid = Math.floor(arr.length / 2); let left = mergeSort(arr.slice(0, mid)); let right = mergeSort(arr.slice(mid)); return merge(left, right); } function merge(left, right) { let result = [], i = 0, j = 0; while (i < left.length && j < right.length) { result.push(left[i] < right[j] ? left[i++] : right[j++]); } return result.concat(left.slice(i)).concat(right.slice(j)); }",
        "quick": "function quickSort(arr) { if (arr.length <= 1) return arr; let pivot = arr[arr.length - 1]; let left = arr.filter(x => x < pivot); let middle = arr.filter(x => x === pivot); let right = arr.filter(x => x > pivot); return [...quickSort(left), ...middle, ...quickSort(right)]; }",
        "heap": "function heapSort(arr) { let n = arr.length; function heapify(n, i) { let largest = i, left = 2 * i + 1, right = 2 * i + 2; if (left < n && arr[left] > arr[largest]) largest = left; if (right < n && arr[right] > arr[largest]) largest = right; if (largest !== i) { [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(n, largest); } } for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(n, i); for (let i = n - 1; i > 0; i--) { [arr[0], arr[i]] = [arr[i], arr[0]]; heapify(i, 0); } return arr; }",
        "counting": "function countingSort(arr) { let max = Math.max(...arr); let count = new Array(max + 1).fill(0); arr.forEach(num => count[num]++); return count.flatMap((c, i) => Array(c).fill(i)); }",
        "radix": "function radixSort(arr) { let maxNum = Math.max(...arr).toString().length; for (let i = 0; i < maxNum; i++) { let buckets = Array.from({ length: 10 }, () => []); arr.forEach(num => { let digit = Math.floor(num / Math.pow(10, i)) % 10; buckets[digit].push(num); }); arr = [].concat(...buckets); } return arr; }",
        "shell": "function shellSort(arr) { let n = arr.length, gap = Math.floor(n / 2); while (gap > 0) { for (let i = gap; i < n; i++) { let temp = arr[i], j = i; while (j >= gap && arr[j - gap] > temp) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } gap = Math.floor(gap / 2); } return arr; }"
    }
}